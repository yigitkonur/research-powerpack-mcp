# Research Powerpack MCP Server - Tool Configuration (ENHANCED)
# Single source of truth for all tool metadata, descriptions, and parameter schemas
# Version: 1.0-enhanced
# Optimization: ~60% token reduction from original, 95%+ instructional context preserved

version: "1.0"

metadata:
  name: "research-powerpack-mcp"
  description: "Research tools for AI assistants"

# ============================================================================
# SHARED PRINCIPLES - Apply to ALL tools
# ============================================================================
shared:
  core_philosophy: |
    These tools are designed for COMPREHENSIVE research through parallel processing.
    Using minimal inputs wastes the parallel capacity. Always maximize input diversity.
    
  principles:
    diversity: |
      Maximize input diversity. More items = better coverage = higher quality output.
      Each input should target a DIFFERENT angle - no overlap, no duplicates.
      
    iteration: |
      ALWAYS use sequentialthinking between tool calls to:
      - Evaluate what you found
      - Identify gaps in coverage
      - Notice new angles from results
      - Decide whether to iterate or proceed
      Results are feedback - use them to ask better questions!
      
    parallel: |
      All items process in parallel - no time penalty for more items.
      Use the maximum recommended count for comprehensive coverage.
      
  workflow_pattern: |
    MANDATORY for all research:
    1. THINK FIRST ‚Üí Plan your query/question strategy
    2. EXECUTE TOOL ‚Üí Run with diverse inputs  
    3. THINK AFTER ‚Üí Evaluate results, identify gaps
    4. ITERATE OR PROCEED ‚Üí Refine and repeat if needed, or move to next tool
    5. SYNTHESIZE ‚Üí Combine insights into final output
    
    Why this works: Initial queries often miss important perspectives.
    Each iteration reveals what you SHOULD have asked!
    
  scope_expansion_triggers: |
    Iterate when:
    - Results mention concepts you didn't research
    - Answers raise new questions you should explore
    - You realize initial scope was too narrow
    - You discover related topics that matter
    - You need deeper understanding of a specific aspect
    
    Key Insight: First research reveals what you SHOULD have asked!

# ============================================================================
# TOOLS
# ============================================================================
tools:
  # --------------------------------------------------------------------------
  # REDDIT TOOLS
  # --------------------------------------------------------------------------
  - name: search_reddit
    category: reddit
    capability: search
    limits:
      min_queries: 10
      max_queries: 50
      recommended_queries: 20
    
    description: |
      **üî• REDDIT SEARCH - MINIMUM 10 QUERIES, RECOMMENDED 20+**
      
      This tool is designed for consensus analysis through MULTIPLE diverse queries.
      Using 1-3 queries = wasting the tool's power. You MUST use 10+ queries minimum.
      
      **Budget:** 10 results per query, all run in parallel.
      - 10 queries = 100 results
      - 20 queries = 200 results (RECOMMENDED)
      - 50 queries = 500 results (comprehensive)
      
      **10-Category Query Formula** - Each query targets a DIFFERENT angle. NO OVERLAP!
      
      1. **Direct topic:** "[topic] [platform]"
         Example: "YouTube Music Mac app"
      2. **Recommendations:** "best/recommended [topic]"
         Example: "best YouTube Music client Mac"
      3. **Specific tools:** Project names, GitHub repos
         Example: "YTMDesktop", "th-ch youtube-music"
      4. **Comparisons:** "[A] vs [B]"
         Example: "YouTube Music vs Spotify Mac desktop"
      5. **Alternatives:** "[topic] alternative/replacement"
         Example: "YouTube Music Mac alternative"
      6. **Subreddits:** "r/[subreddit] [topic]" - different communities have different perspectives
         Example: "r/macapps YouTube Music", "r/opensource YouTube Music"
      7. **Problems/Issues:** "[topic] issues/crashes/problems"
         Example: "YouTube Music Mac crashes", "YTM desktop performance problems"
      8. **Year-specific:** Add "2024" or "2025" for recent discussions
         Example: "best YouTube Music Mac 2024"
      9. **Features:** "[topic] [specific feature]"
         Example: "YouTube Music offline Mac", "YTM lyrics desktop"
      10. **Developer/GitHub:** "[topic] GitHub/open source/electron"
          Example: "youtube-music electron GitHub", "YTM desktop open source"
      
      **Search Operators:**
      - `intitle:` - Search in post titles only
      - `"exact phrase"` - Match exact phrase
      - `OR` - Match either term
      - `-exclude` - Exclude term
      - All queries auto-add `site:reddit.com`
      
      **Example showing all 10 categories:**
      ‚ùå BAD: `{"queries": ["best YouTube Music app"]}` ‚Üí 1 vague query, misses 90% of consensus
      ‚úÖ GOOD: `{"queries": ["YouTube Music Mac app", "best YTM client Mac", "YTMDesktop Mac", "YouTube Music vs Spotify Mac", "YouTube Music Mac alternative", "r/macapps YouTube Music", "YTM Mac crashes", "YouTube Music Mac 2024", "YTM offline Mac", "youtube-music GitHub", ...expand to 20 queries]}` ‚Üí comprehensive multi-angle coverage
      
      **Pro Tips:**
      1. **Use ALL 10 categories** - Each reveals different community perspectives
      2. **Target specific subreddits** - Different communities have different expertise
      3. **Include year numbers** - "2024", "2025" filters for recent discussions
      4. **Add comparison keywords** - "vs", "versus" find decision threads
      5. **Include problem keywords** - "issue", "bug", "crash" find real experiences
      6. **Vary phrasing** - "best", "top", "recommended" capture different discussions
      7. **Use technical terms** - "electron", "GitHub", "API" find developer perspectives
      8. **NO DUPLICATES** - Each query must target a unique angle
      
      **Workflow:**
      search_reddit ‚Üí sequentialthinking (evaluate results) ‚Üí get_reddit_post OR search again ‚Üí sequentialthinking ‚Üí synthesize
      
      **REMEMBER:** More queries = better consensus detection = higher quality results!

    parameters:
      queries:
        type: array
        required: true
        items:
          type: string
        validation:
          minItems: 10
          maxItems: 50
        description: |
          **10-50 diverse queries** (Minimum 10 required, 20-30 recommended)
          
          Each query MUST target a different angle using the 10-category formula.
          No duplicates, no overlap - maximize diversity for comprehensive consensus.
          
          **Quick Checklist:**
          ‚úì Direct topic queries
          ‚úì Recommendation queries ("best", "recommended")
          ‚úì Specific tool/project names
          ‚úì Comparisons ("vs", "versus")
          ‚úì Subreddit targeting ("r/...")
          ‚úì Year-specific (2024, 2025)
          ‚úì Problem keywords (issue, bug, crash)
          ‚úì Feature keywords
          ‚úì Developer angle (GitHub, open source)

      date_after:
        type: string
        required: false
        description: "Filter results after date (YYYY-MM-DD). Example: '2024-01-01'"

  # --------------------------------------------------------------------------
  - name: get_reddit_post
    category: reddit
    capability: reddit
    limits:
      min_urls: 2
      max_urls: 50
      recommended_urls: 20
      default_max_comments: 1000
    
    description: |
      **üî• FETCH REDDIT POSTS - 2-50 URLs, RECOMMENDED 10-20+**
      
      This tool fetches Reddit posts with smart comment allocation.
      Using 2-5 posts = missing community consensus. Use 10-20+ for broad perspective.
      
      **Comment Budget:** 1,000 total comments distributed automatically across posts.
      - 2 posts: ~500 comments/post (deep dive)
      - 10 posts: ~100 comments/post (balanced)
      - 20 posts: ~50 comments/post (RECOMMENDED: broad)
      - 50 posts: ~20 comments/post (max coverage)
      
      Comment allocation is AUTOMATIC - you don't need to calculate!
      
      **When to use different post counts:**
      
      **2-5 posts:** Deep dive on specific discussions
      - Use when: You found THE perfect thread and want all comments
      - Trade-off: Deep but narrow perspective
      
      **10-15 posts:** Balanced depth + breadth (GOOD)
      - Use when: Want good comment depth across multiple discussions
      - Trade-off: Good balance of depth and coverage
      
      **20-30 posts:** Broad community perspective (RECOMMENDED)
      - Use when: Want to see consensus across many discussions
      - Trade-off: Less comments per post but more diverse opinions
      
      **40-50 posts:** Maximum coverage
      - Use when: Researching controversial topic, need all perspectives
      - Trade-off: Fewer comments per post but comprehensive coverage
      
      **Example:**
      ‚ùå BAD: `{"urls": ["single_url"]}` ‚Üí 1 perspective, could be biased/outdated
      ‚úÖ GOOD: `{"urls": [20 URLs from diverse subreddits: programming, webdev, node, golang, devops, etc.]}` ‚Üí comprehensive community perspective
      
      **Pro Tips:**
      1. **Use 10-20+ posts** - More posts = broader community perspective
      2. **Mix subreddits** - Different communities have different expertise and perspectives
      3. **Include various discussion types** - Best practices, comparisons, problems, solutions
      4. **Let comment allocation auto-adjust** - Don't override max_comments unless needed
      5. **Use after search_reddit** - Get URLs from search, then fetch full content here
      
      **CRITICAL:** Comments often contain the BEST insights, solutions, and real-world experiences.
      Always set fetch_comments=true unless you only need post titles.
      
      **Workflow:** search_reddit (find posts) ‚Üí get_reddit_post (fetch full content + comments)

    parameters:
      urls:
        type: array
        required: true
        items:
          type: string
        validation:
          minItems: 2
          maxItems: 50
        description: |
          **2-50 Reddit post URLs** (Minimum 2, recommended 10-20)
          
          More posts = broader community perspective and better consensus detection.
          Get URLs from search_reddit results, then fetch full content here.

      fetch_comments:
        type: boolean
        required: false
        default: true
        description: |
          **Fetch comments from posts (RECOMMENDED: true)**
          
          Comments often contain the BEST insights, solutions, and real-world experiences.
          Set to true (default): Get post + comments
          Set to false: Get post content only (faster but misses insights)

      max_comments:
        type: number
        required: false
        default: 100
        description: |
          **Override automatic comment allocation**
          
          Leave empty for smart allocation based on post count:
          - 2 posts: ~500 comments/post
          - 10 posts: ~100 comments/post
          - 20 posts: ~50 comments/post
          
          Only override if you need specific comment depth.

  # --------------------------------------------------------------------------
  # DEEP RESEARCH TOOL
  # --------------------------------------------------------------------------
  - name: deep_research
    category: research
    capability: deepResearch
    useZodSchema: true
    zodSchemaRef: "deepResearchParamsSchema"
    limits:
      min_questions: 1
      max_questions: 10
      recommended_questions: 5
      min_question_length: 200
      min_specific_questions: 2
    
    description: |
      **üî• DEEP RESEARCH - 2-10 QUESTIONS, RECOMMENDED 5+**
      
      This tool runs 2-10 questions IN PARALLEL with AI-powered research.
      Using 1-2 questions = wasting the parallel research capability!
      
      **Token Budget:** 32,000 tokens distributed across questions.
      - 2 questions: 16,000 tokens each (deep dive)
      - 5 questions: 6,400 tokens each (RECOMMENDED: balanced)
      - 10 questions: 3,200 tokens each (comprehensive multi-topic)
      
      All questions research in PARALLEL - no time penalty for more questions!
      
      **When to use this tool:**
      - Multi-perspective analysis on related topics
      - Researching a domain from multiple angles
      - Validating understanding across different aspects
      - Comparing approaches/technologies side-by-side
      - Deep technical questions requiring comprehensive research
      
      **Question Template** - Each question MUST include these sections:
      
      1. **üéØ WHAT I NEED:** Clearly state what you're trying to achieve or understand
      2. **ü§î WHY I'M RESEARCHING:** What decision does this inform? What problem are you solving?
      3. **üìö WHAT I ALREADY KNOW:** Share current understanding so research fills gaps, not repeats basics
      4. **üîß HOW I'LL USE THIS:** Practical application - implementation, debugging, architecture
      5. **‚ùì SPECIFIC QUESTIONS (2-5):** Break down into specific, pointed sub-questions
      6. **üåê PRIORITY SOURCES:** (optional) Preferred docs/sites to prioritize
      7. **‚ö° FOCUS AREAS:** (optional) What matters most - performance, security, etc.
      
      **ATTACH FILES when asking about code - THIS IS MANDATORY:**
      - üêõ Bugs/errors ‚Üí Attach the failing code
      - ‚ö° Performance issues ‚Üí Attach the slow code paths
      - ‚ôªÔ∏è Refactoring ‚Üí Attach current implementation
      - üîç Code review ‚Üí Attach code to review
      - üèóÔ∏è Architecture ‚Üí Attach relevant modules
      
      Research without code context for code questions is generic and unhelpful!
      
      **Example:**
      ‚ùå BAD: `{"questions": [{"question": "Research React hooks"}]}` ‚Üí 1 vague question, no template, no context, wastes 90% capacity
      
      ‚úÖ GOOD: 
      ```json
      {"questions": [{
        "question": "üéØ WHAT I NEED: Understand when to use useCallback vs useMemo in React 18\n\nü§î WHY: Optimizing a data-heavy dashboard with 50+ components, seeing performance issues\n\nüìö WHAT I KNOW: Both memoize values, useCallback for functions, useMemo for computed values. Unclear when each actually prevents re-renders.\n\nüîß HOW I'LL USE THIS: Refactor Dashboard.tsx to eliminate unnecessary re-renders\n\n‚ùì SPECIFIC QUESTIONS:\n1. When does useCallback actually prevent re-renders vs when it doesn't?\n2. Performance benchmarks: useCallback vs useMemo vs neither in React 18?\n3. Common anti-patterns that negate their benefits?\n4. How to measure if they're actually helping?\n\nüåê PRIORITY: Official React docs, React team blog posts\n‚ö° FOCUS: Patterns for frequently updating state"
      }, ...add 4 more questions for comprehensive coverage]}
      ```
      
      **Pro Tips:**
      1. **Use 5-10 questions** - Maximize parallel research capacity
      2. **Follow the template** - Include all 7 sections for each question
      3. **Be specific** - Include version numbers, error codes, library names
      4. **Add 2-5 sub-questions** - Break down what you need to know
      5. **Attach files for code questions** - MANDATORY for bugs/performance/refactoring
      6. **Describe files thoroughly** - Explain what the file is and what to focus on
      7. **Specify focus areas** - "Focus on X, Y, Z" for prioritization
      8. **Group related questions** - Research a domain from multiple angles
      
      **Scope Expansion Triggers** - Iterate when:
      - Results mention concepts you didn't research
      - Answers raise new questions you should explore
      - You realize initial scope was too narrow
      - You discover related topics that matter
      
      **Workflow:**
      deep_research (3-5 questions) ‚Üí sequentialthinking (evaluate, identify gaps) ‚Üí 
      OPTIONAL: deep_research AGAIN with NEW questions based on learnings ‚Üí 
      sequentialthinking (synthesize) ‚Üí final decision
      
      **REMEMBER:**
      - ALWAYS think after getting results (digest and identify gaps!)
      - DON'T assume first research is complete (iterate based on findings!)
      - USE learnings to ask better questions (results = feedback!)
      - EXPAND scope when results reveal new important areas!

    schemaDescriptions:
      questions: |
        **2-10 structured questions following the template**
        
        Each question should cover a different angle of your research topic.
        Attach files for any code-related questions - this is mandatory!
        
      file_attachments: |
        **MANDATORY for code questions: bugs, performance, refactoring, code review, architecture**
        
        Format: {path: "/absolute/path", description: "What this file is, why relevant, what to focus on", start_line?, end_line?}
        
        Use absolute paths. Include thorough description explaining the file's relevance,
        focus areas, and known issues.

  # --------------------------------------------------------------------------
  # SCRAPE LINKS TOOL
  # --------------------------------------------------------------------------
  - name: scrape_links
    category: scrape
    capability: scraping
    useZodSchema: true
    zodSchemaRef: "scrapeLinksParamsSchema"
    limits:
      min_urls: 1
      max_urls: 50
      recommended_urls: 5
      min_extraction_prompt_length: 50
      min_extraction_targets: 3
    
    description: |
      **üî• WEB SCRAPING - 1-50 URLs, RECOMMENDED 3-5. ALWAYS use_llm=true**
      
      This tool has TWO modes:
      1. **Basic scraping** (use_llm=false) - Gets raw HTML/text - messy, requires manual parsing
      2. **AI-powered extraction** (use_llm=true) - Intelligently extracts what you need ‚≠ê **USE THIS!**
      
      **‚ö° ALWAYS SET use_llm=true FOR INTELLIGENT EXTRACTION ‚ö°**
      
      **Why use AI extraction (use_llm=true):**
      - Filters out navigation, ads, footers automatically
      - Extracts ONLY what you specify in what_to_extract
      - Handles complex page structures intelligently
      - Returns clean, structured content ready to use
      - Saves hours of manual HTML parsing
      - Cost: pennies (~$0.01 per 10 pages)
      
      **Token Budget:** 32,000 tokens distributed across URLs.
      - 3 URLs: ~10,666 tokens each (deep extraction)
      - 5 URLs: ~6,400 tokens each (RECOMMENDED: balanced)
      - 10 URLs: ~3,200 tokens each (detailed)
      - 50 URLs: ~640 tokens each (quick scan)
      
      **Extraction Prompt Formula:**
      ```
      Extract [target1] | [target2] | [target3] | [target4] | [target5]
      with focus on [aspect1], [aspect2], [aspect3]
      ```
      
      **Extraction Rules:**
      - Use pipe `|` to separate extraction targets
      - Minimum 3 targets required
      - Be SPECIFIC about what you want ("pricing tiers" not "pricing")
      - Include "with focus on" to prioritize certain aspects
      - More targets = more comprehensive extraction
      - Aim for 5-10 extraction targets
      
      **Extraction Templates by Domain:**
      
      **Product Research:**
      ```
      Extract pricing details | feature comparisons | user reviews | technical specifications | 
      integration options | support channels | deployment models | security features 
      with focus on enterprise capabilities, pricing transparency, and integration complexity
      ```
      
      **Technical Documentation:**
      ```
      Extract API endpoints | authentication methods | rate limits | error codes | 
      request examples | response schemas | SDK availability | webhook support 
      with focus on authentication flow, rate limiting policies, and error handling patterns
      ```
      
      **Competitive Analysis:**
      ```
      Extract product features | pricing models | target customers | unique selling points | 
      technology stack | customer testimonials | case studies | market positioning 
      with focus on differentiators, pricing strategy, and customer satisfaction
      ```
      
      **Example:**
      ‚ùå BAD: `{"urls": ["url"], "use_llm": false, "what_to_extract": "get pricing"}` ‚Üí raw HTML, vague prompt, 1 target, no focus areas
      
      ‚úÖ GOOD: `{"urls": [5 URLs], "use_llm": true, "what_to_extract": "Extract pricing tiers | plan features | API rate limits | enterprise options | integration capabilities | user testimonials with focus on enterprise features, API limitations, and real-world performance data"}` ‚Üí clean structured extraction
      
      **Pro Tips:**
      1. **ALWAYS use use_llm=true** - The AI extraction is the tool's superpower
      2. **Use 3-10 URLs** - Balance between depth and breadth
      3. **Specify 5-10 extraction targets** - More targets = more comprehensive
      4. **Use pipe `|` separators** - Clearly separate each target
      5. **Add focus areas** - "with focus on X, Y, Z" for prioritization
      6. **Be specific** - "pricing tiers" not "pricing", "API rate limits" not "API info"
      7. **Cover multiple aspects** - Features, pricing, technical, social proof
      
      **Automatic Fallback:** Basic ‚Üí JavaScript rendering ‚Üí JavaScript + US geo-targeting
      **Batching:** Max 30 concurrent requests (50 URLs = [30] then [20] batches)
      
      **REMEMBER:** AI extraction costs pennies but saves hours of manual parsing!

    schemaDescriptions:
      urls: |
        **1-50 URLs to scrape** (3-5 recommended for balanced depth/breadth)
        
        More URLs = broader coverage but fewer tokens per URL.
        - 3 URLs: ~10K tokens each (deep)
        - 5 URLs: ~6K tokens each (balanced)
        - 10 URLs: ~3K tokens each (detailed)
        
      timeout: "Timeout per URL (5-120 seconds, default: 30)"
      
      use_llm: |
        **‚ö° ALWAYS SET TO true FOR INTELLIGENT EXTRACTION ‚ö°**
        
        Enables AI-powered content extraction that:
        - Filters out navigation, ads, footers automatically
        - Extracts ONLY what you specify in what_to_extract
        - Handles complex page structures intelligently
        - Returns clean, structured content
        
        Cost: pennies (~$0.001 per page)
        Default: false (but you should ALWAYS set it to true!)
        
      what_to_extract: |
        **Extraction prompt for AI (REQUIRED when use_llm=true)**
        
        Formula: Extract [target1] | [target2] | [target3] with focus on [aspect1], [aspect2]
        
        Requirements:
        - Minimum 50 characters (be detailed!)
        - Minimum 3 extraction targets separated by `|`
        - Include "with focus on" for prioritization
        - Be SPECIFIC about what you want
        
        More specific targets = better extraction quality!

  # --------------------------------------------------------------------------
  # WEB SEARCH TOOL
  # --------------------------------------------------------------------------
  - name: web_search
    category: search
    capability: search
    useZodSchema: true
    zodSchemaRef: "webSearchParamsSchema"
    limits:
      min_keywords: 3
      max_keywords: 100
      recommended_keywords: 7
    
    description: |
      **üî• WEB SEARCH - MINIMUM 3 KEYWORDS, RECOMMENDED 5-7**
      
      This tool searches up to 100 keywords IN PARALLEL via Google.
      Using 1-2 keywords = wasting the tool's parallel search power!
      
      **Results Budget:** 10 results per keyword, all searches run in parallel.
      - 3 keywords = 30 results (minimum)
      - 7 keywords = 70 results (RECOMMENDED)
      - 100 keywords = 1000 results (comprehensive)
      
      **7-Perspective Keyword Formula** - Each keyword targets a DIFFERENT angle:
      
      1. **Direct/Broad:** "[topic]"
         Example: "React state management"
      2. **Specific/Technical:** "[topic] [technical term]"
         Example: "React useReducer vs Redux"
      3. **Problem-Focused:** "[topic] issues/debugging/problems"
         Example: "React state management performance issues"
      4. **Best Practices:** "[topic] best practices [year]"
         Example: "React state management best practices 2024"
      5. **Comparison:** "[A] vs [B]"
         Example: "React state management libraries comparison"
      6. **Tutorial/Guide:** "[topic] tutorial/guide"
         Example: "React state management tutorial"
      7. **Advanced:** "[topic] patterns/architecture large applications"
         Example: "React state management patterns large applications"
      
      **Search Operators with Examples:**
      - `site:domain.com` - Search within specific site
        Example: `"React hooks" site:github.com` ‚Üí React hooks repos on GitHub
      - `"exact phrase"` - Match exact phrase
        Example: `"Docker OOM" site:stackoverflow.com` ‚Üí exact error discussions
      - `-exclude` - Exclude term from results
        Example: `React state management -Redux` ‚Üí find alternatives to Redux
      - `filetype:pdf` - Find specific file types
        Example: `React tutorial filetype:pdf` ‚Üí downloadable guides
      - `OR` - Match either term
        Example: `React OR Vue state management` ‚Üí compare frameworks
      
      **Keyword Patterns by Use Case:**
      
      **Technology Research:**
      `["PostgreSQL vs MySQL performance 2024", "PostgreSQL best practices production", "\"PostgreSQL\" site:github.com stars:>1000", "PostgreSQL connection pooling", "PostgreSQL vs MongoDB use cases"]`
      
      **Problem Solving:**
      `["Docker container memory leak debugging", "Docker memory limit not working", "\"Docker OOM\" site:stackoverflow.com", "Docker memory optimization best practices"]`
      
      **Comparison Research:**
      `["Next.js vs Remix performance", "Next.js 14 vs Remix 2024", "\"Next.js\" OR \"Remix\" benchmarks", "Next.js vs Remix developer experience"]`
      
      **Example:**
      ‚ùå BAD: `{"keywords": ["React"]}` ‚Üí 1 vague keyword, no operators, no diversity
      
      ‚úÖ GOOD: `{"keywords": ["React state management best practices", "React useReducer vs Redux 2024", "React Context API performance", "Zustand React state library", "\"React state\" site:github.com", "React state management large applications", "React global state alternatives -Redux"]}` ‚Üí 7 diverse angles with operators
      
      **Pro Tips:**
      1. **Use 5-7 keywords minimum** - Each reveals different perspective
      2. **Add year numbers** - "2024", "2025" for recent content
      3. **Use search operators** - site:, "exact", -exclude, filetype:
      4. **Vary specificity** - Mix broad + specific keywords
      5. **Include comparisons** - "vs", "versus", "compared to", "OR"
      6. **Target sources** - site:github.com, site:stackoverflow.com
      7. **Add context** - "best practices", "tutorial", "production", "performance"
      8. **Think parallel** - Each keyword searches independently
      
      **Workflow:**
      web_search ‚Üí sequentialthinking (evaluate which URLs look promising) ‚Üí 
      scrape_links (MUST scrape promising URLs - that's where real content is!) ‚Üí 
      sequentialthinking (evaluate scraped content) ‚Üí 
      OPTIONAL: web_search again if gaps found ‚Üí synthesize
      
      **Why this workflow works:**
      - Search results reveal new keywords you didn't think of
      - Scraped content shows what's actually useful vs what looked good
      - Thinking between tool calls prevents tunnel vision
      - Iterative refinement = comprehensive coverage
      
      **CRITICAL:**
      - ALWAYS scrape after web_search - that's where the real content is!
      - ALWAYS think between tool calls - evaluate and refine!
      - DON'T stop after one search - iterate based on learnings!
      
      **FOLLOW-UP:** Use `scrape_links` to extract full content from promising URLs!

    schemaDescriptions:
      keywords: |
        **3-100 diverse keywords** (Minimum 3 required, 5-7 recommended)
        
        Each keyword runs as a separate Google search in parallel.
        Each keyword should target a different angle using the 7-perspective formula.
        
        **Diversity Checklist:**
        ‚úì Includes broad keyword
        ‚úì Includes specific/technical keyword
        ‚úì Includes comparison keyword (vs, OR)
        ‚úì Includes best practices keyword
        ‚úì Includes year-specific keyword (2024, 2025)
        ‚úì Uses search operators (site:, "exact", -exclude)
        ‚úì Targets specific sources (GitHub, Stack Overflow, docs)
        
        **Search Operators:**
        - `site:domain.com` - Search within site
        - `"exact phrase"` - Match exact phrase
        - `-exclude` - Exclude term
        - `filetype:pdf` - Find file type
        - `OR` - Match either term
